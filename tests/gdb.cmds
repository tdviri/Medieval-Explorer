# Set breakpoint at the start of your desired function.
# Replace 'your_function' with the appropriate function name.
break loadData

commands
  silent
  # When the breakpoint is hit, obtain the return address and set a temporary breakpoint at that address
  set $ret_address = *(unsigned long*)($sp)
  break *$ret_address

  # Continue execution to proceed to the temporary breakpoint
  cont
end

info b
# Define what should be executed when the temporary breakpoint (at the return address) is hit.
# Assuming the temporary breakpoint is breakpoint 2; adjust if not.
#break *$ret_address

commands
  silent
  set $ptr_address = (long)rooms
  set $heap_start = 0
  set $heap_end = 0

  # Parse the output of 'info proc mappings' to find the heap bounds
python
try:
    proc_mappings = gdb.execute("info proc mappings", to_string=True)
    heap_line = next(line for line in proc_mappings.split('\n') if 'heap' in line)
    heap_start_value, heap_end_value = heap_line.split()[0], heap_line.split()[1]
    gdb.execute('set $heap_start = {}'.format(heap_start_value))
    gdb.execute('set $heap_end = {}'.format(heap_end_value))
except Exception as e:
    print("Error parsing heap bounds: " + str(e))
end


  # Check if pointer is within heap bounds
  if $ptr_address >= $heap_start && $ptr_address <= $heap_end
    printf "Pointer target is on the heap.\n"
  else
    printf "Pointer target is NOT on the heap.\n"
  end

  # Continue execution after commands
  quit

end

set disable-randomization off
# Start program execution
run
